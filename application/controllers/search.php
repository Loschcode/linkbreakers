<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

/**
 * Search Controller
 *
 * Here we make all our research effective
 *
 * @author		Laurent SCHAFFNER
 * @copyright   2013
 * @category	Controller
 *
 */

class Search extends CI_Controller {

	public function __construct() {

		parent::__Construct();

		// Load models
		$this->load->model('general_model');
		$this->load->model('log_model');

		// We set important cookies in case there are empty
		//if (!$this->pikachu->show('userid')) {

			if ($this->pikachu->get_cookie('prefs_default_result_enabled') === NULL) $this->pikachu->set_cookie('prefs_default_result_enabled', '1');
			if ($this->pikachu->get_cookie('prefs_smart_domains_enabled') === NULL) $this->pikachu->set_cookie('prefs_smart_domains_enabled', '1');
			if ($this->pikachu->get_cookie('prefs_clever_returns_enabled') === NULL) $this->pikachu->set_cookie('prefs_clever_returns_enabled', '0');
		
		//} <-- it doesn't depend on userid at the end (added 23/01/2014)

		// Set page
		$this->template->set('page', 'search');

		// We load 'tag' langs because of EDIT YOUR LAST CREATION / MAKE YOUR IDEA label_button
		$this->lang->load('tag');

		// Check cookie/session secured synchronization -> If not, auto_auth is engaged
		if (!$this->pikachu->show('sync')) if ($arr = $this->pikachu->auto_auth()) $this->log_model->session_auth($arr); 


	}

	/**
	 * Make a benchmark through our server request
	 *
	 * @access protected
	 * @param bool $exec_stat whether the benchmark has to stop (FALSE) or start (TRUE)
	 * @return	void
	 */
	protected function benchIt($exec_stat=FALSE) {

		if ($exec_stat) {

			$this->benchmark = new CI_Benchmark();
			$this->benchmark->mark('request_start');

		} else {

			$this->benchmark->mark('request_end');
			die($this->benchmark->elapsed_time('request_start', 'request_end'));
		}

	}

	/**
	 * We fill our Research API with new sessions
	 *
	 * @access protected
	 * @param string $search_text the researched text
	 * @param mixed $result usually the final URL or NULL
	 * @param string $result_type which kind of result has been output ?
	 * @return void
	 */
	protected function connect_research_api($search_text, $result, $result_type) {

		// If our clever returns system isn't enabled, we destroy everything about this API and exit the function
		$prefs_clever_returns_enabled = get_boolean_prefs('prefs_clever_returns_enabled');

		// We will get the MIME type of the reply (if it's an URL)
		if ($result_type === 'normal_process') {

			if (!$headers = @get_headers($result, 1)) $headers = array();

			// The MIME type
			$result_mime = isset($headers["Content-Type"]) ? $headers["Content-Type"] : FALSE;

			// The content disposition, would be the system which says if it's downloadable
			$result_disposition = isset($headers["Content-Disposition"]) ? $headers["Content-Disposition"] : FALSE;

			// We get the last element in case it's a multi-headers response
			if (is_array($result_mime)) $result_mime = end($result_mime);

		} else {

			$result_mime = FALSE;
			$result_disposition = FALSE;

		}

		Devlog::add('Research "'.$search_text.'" finally returned "'.$result.'" (MIME '.$result_mime.') ; the server replied as a '.$result_type.' result');
		if ($result_disposition) Devlog::add('This result match has been recognized as a downloadable content ('.$result_disposition.')');
		Devlog::save();

		/**
		 *
		 * POSSIBLE RESULT TYPES :
		 * --------
		 * normal_process		results found in our database classically
		 * intern_url 			it's not an external redirection (usually #tools/example)
		 * smart_domain 		there's no real result, it's a smart domain redirection
		 *
		 * form_error			there's no result and a form_error
		 * space_redirection 	there's no result, the result is generated by the user page (personal search engine)
		 * default_result 		there's no result, we go through the default result system (usually Google but could be dynamic)
		 * tag_result 			there's no result, we go through the "make a new idea" page already half-filled
		 *
		 */

		$this->pikachu->multi_set( 

			array(

				'search_text' => $search_text,
				'result' => $result,
				'result_type' => $result_type,
				'result_time' => time(),
				'result_mime' => $result_mime,
				'result_attachment' => $result_disposition

			), 'research');

	}

	/**
	 * We call mistertools class and generate a tool action
	 * It was originally within the index method and refactorized here to be clean
	 * After this call, we usually put an exit() after the method
	 * Because it calls another Linkbreakers section
	 *
	 * @access	public
	 * @param   string $search_text the treated search_text
	 * @param   string $intern_url the intern_url we will try to execute
	 * @return	void
	 */
	protected function mistertools_call($search_text, $intern_url) {

		// HIGH POSSIBILITY OF FAILURE IF YOUR SPLITTING SOMETHING ELSE THAN TOOLS
		if (strpos($intern_url, '/')) {

			$arr_url = explode('/', $intern_url);

			if ($arr_url[0] === 'tools') {

				$method_name = $arr_url[1];
				$this->load->library('volt/mistertools');

				$research_api_output = '('.$intern_url.') '.$this->pikachu->show($intern_url);

				$this->connect_research_api($search_text, $research_api_output, 'intern_url');

				$this->mistertools->$method_name($this->pikachu->show($intern_url)); // Calling the session to be the argument

			}

		}

	}

	/**
	 * We check if the result is an intern_url
	 * If it's an intern_url we reply with a mistertools call and we exit the application
	 *
	 * @access	public
	 * @param   string url the intern url to identify and treat (e.g '#tools/text ...')
	 * @param   array $research_details all the research details we collected during the treatment
	 * @return	void
	 */
	protected function throw_intern_url_exception($url, array $research_details) {

		if (is_intern_url($url)) {

			$url = $this->panda->understand_intern_url($url, $research_details);

			$this->mistertools_call($research_details['search_text'], $url);
			exit();

		}

	}

	/**
	 * We normalize the get research (originally got from a URL encoded format)
	 * At the end of this function, the string must be similar than a non-URL string
	 * Because many treatments will be done afterwards and it has to perfectly fit with the treatment
	 *
	 * @access	public
	 * @param   string the request which's from an URL
	 * @return	void
	 */
	protected static function normalize_get_research($get_request) {

		$get_request = rawurldecode($get_request);

		//$get_request = utf8_decode($get_request); // -> Deleted August 2013 -> because of google translate bugs

		$get_request = mb_convert_encoding($get_request, 'UTF-8', 'auto');

		// We decode the URL
		$get_request = html_entity_decode($get_request); // Motherfucker "()" big bug -> CodeIgniter encode entities in controller, i don't know why. 7 fucking hours to find it out.

		return $get_request;

	}

	/**
	 * Add datas to our search system to search from private inside search engines
	 *
	 * @access	public
	 * @param integer/string $user the id or name of the user we're going through
	 * @param strring $search our research
	 * @return	void
	 */
	public function from_user($user=0, $search='') {

		$this->form_validation->set_get('request', $search);
		$this->form_validation->set_post('by_specific_user', $user);

		Devlog::add('Request from user space "'.$user.'" launched');

		//var_dump($_SERVER['REQUEST_URI'])

		$this->index();

	}

	/**
	 * Clever returns after push OR come back handling controller
	 *
	 * @access	public
	 * @return	void
	 */
	public function clever_returns_pushback() {

		$this->load->view('prefs/clever_returns_pushback');

	}

	/**
	 * Linkbreakers Search System
	 *
	 * @access	public
	 * @return	void
	 */
	public function index() {

		// Research details
		$research_details = array();

		// Options to set
		$opt_raw_benchmark = FALSE;
		$opt_force_no_result = FALSE;

		/*
		 * There's a quite secret option system within Linkbreakers researches
		 * Just add someting like '&opt=' and what you want to launch the different options
		 *
		 * Raw_benchmark : display a research benchmark instead of searching
		 * No_result : force a no result with the classic mechanism
		 *
		 */
		if ($this->input->get('opt')) {

			$request_option = $this->input->get('opt');
			if ($request_option === 'raw_benchmark') $opt_raw_benchmark = TRUE;
			elseif ($request_option === 'no_result') $opt_force_no_result = TRUE;

		}

		// Benchmark system
		if ($opt_raw_benchmark) $this->benchIt(TRUE);

		/*
		 * If search_text isn't set, it means this is from a URL (as said above)
		 * So we launch a cleaning series to norm the research text
		 * At the end of this operation, the research text has to be similar to a $_post one
		 */
		if (!$this->input->post('search_text')) {

			// We will do some treatments correspondig to the URL get request
			$get_request = $this->normalize_get_research($this->input->get('request'));

			// Finally, we auto-set the search_text post
			$this->form_validation->set_post('search_text', $get_request);

		}

		/*
		 * Now we are cleaning the search_text (just a little for the first part) and we put it within $raw_search_text
		 * This is done not depending on the research method (URL or POST)
		 */

		// Clean strings
		$raw_search_text = trim($this->panda->trim_lines($this->input->post('search_text')));
		$raw_search_text = delete_double_spaces($raw_search_text);

		// If there's a defined prefix within the form, we reset the string before the form_validation
		if (($this->input->post('prefix_search_text')) && (!empty($raw_search_text))) $raw_search_text = $this->input->post('prefix_search_text').$raw_search_text;

		$this->form_validation->set_post('search_text', $raw_search_text);

		// Check string and modify
		$this->form_validation->set_rules('search_text', 'search text', 'required|xss_clean');
		$this->form_validation->set_rules('voice', 'voice', 'numeric');

		$this->form_validation->set_rules('by_specific_user', 'by_specific_user', 'alpha_dash'); // Option

		if ($this->form_validation->run()) {

			// Define $search_text
			$search_text = $this->input->post('search_text');

			// Voice system
			if ($this->input->post('voice')) $voice = 1;
			else $voice = 0;

			if (!$by_specific_user = $this->input->post('by_specific_user')) {

				$by_specific_user = FALSE;
				$by_specific_user_name = FALSE;

			} else {

				// Check if it's a number (even within a string)
				// From now $by_specific_user will be an ID only
				if (!is_numeric($by_specific_user)) {

					$by_specific_user_name = $by_specific_user;
					$by_specific_user = $this->log_model->find_id_by_username($by_specific_user);

				} else {

					$by_specific_user_name = FALSE;
					$by_specific_user = (int) $by_specific_user; // clean conversion

				}

			}

			$this->pikachu->set('voice', $voice);

			Devlog::add('You requested "'.$search_text.'"');

			/*
			 *
			 * We put everything into an array to transfert the datas
			 * And we keep the changes because variables could be modified after that
			 *
			 */
			$research_details = array(

				'search_text' => &$search_text,
				'raw_search_text' => &$raw_search_text,
				'by_specific_user' => &$by_specific_user,
				'by_specific_user_name' => &$by_specific_user_name

			);

			// Delete forbidden characters
			//$search_text = str_replace("$", "", $search_text);

			while_because_of_wrong_strong_type: // Goto line ~200 (instead of $this->index)

			/*
			 *
			 * NO RESULT OPTION :
			 * This is useful for the CLEVER RETURNS PUSHBACK
			 * As a matter of fact, when we come back for the clever returns
			 * It must be a dynamic response with a dynamic search engine (maybe the user personnalized it)
			 * So the best solution after one fucking night of thinking seems to be a fake no result
			 * This option could also be activated from the url address
			 *
			 */
			if ($opt_force_no_result) $result = FALSE;
			else {

			// One-word system (faster)
			if ($by_specific_user) $result = $this->general_model->find($search_text, $by_specific_user);
			elseif (strpos($search_text, ' ')) $result = $this->general_model->find($search_text, $by_specific_user);
			else $result = $this->general_model->short_find($search_text, $by_specific_user);

			}

			// Look into database
			if ($result) {

				Devlog::add('The server has responded "'.$result['url'].'" (match #'.$result['id'].' "'.$result['string_clean'].'") and will try to process your request');

				// Small and raw check of intern link, disable urlencode because it won't be into any URL
				if (is_intern_url($result['url'])) $urlencode = FALSE;
				else $urlencode = TRUE;

				// Check a linkedid -> if there's a @integer we convert into the real linked URL
				while ($result['url'][0] === '@') {

					$result['url'] = $this->general_model->find_linkedurl_by_id(substr($result['url'], 1), $result['id']);
					Devlog::add('The URL has been recognized as LinkedURL ; it was resolved as "'.$result['url'].'"');

				}

				// We delete the quotation system to search the correct words
				$search_text = str_replace("\"", "", $search_text);
				$search_text = str_replace("  ", " ", $search_text); // avoid single ' " ' words or any failure

				/**
				 * Characters we must encode to don't be misunderstood by the systems
				 * e.g. !tweet machin #bidule truc
				 */
				$search_text = str_replace("#", "%23", $search_text); // Not sure if we should let it here or put it with the '/' exception right below

				// We need to ignore brackets in data understanding, to avoid {FUNCTIONS} errors
				$search_text = encrypt('{', $search_text);
				$search_text = encrypt('}', $search_text);
				//$search_text = encrypt('=', $search_text);

				// We prepare strong types verification (this is here because of [sentence] which is a special strong-type)
				$strong_types = json_decode($result['strong_type'], TRUE);

				// Return an array with valid variables depending on user search -> return no result if strong type doesn't fit
				$var_array = $this->panda->string_to_array($search_text, $result['string_clean'], $strong_types); // We will use strong_types only for [sentence] system

				// Check strong type
				if ($strong_types !== NULL) { // It should work, if it doesn't work correctly around here, delete this (in trying to take the good result)

					if (!$this->panda->check_strong_type($var_array, $strong_types)) {

					Devlog::add('Strongtype check didn\'t reply well ; I think he doesn\'t like you');

					// We set this as an exceptions
					$this->general_model->strong_type_exceptions[] = $result['id'];
					//$this->index();
					goto while_because_of_wrong_strong_type;
					//exit();

					//return $this->no_result($original_search_text, $result, $prefs_default_result_enabled);
					}

				}

				/*
				 *
				 * Here we set the phoenix variables that will be used in other LBL-Libraries
				 * - search_id_creator will be mainly used in lbl_construction
				 *
				 */
				$this->phoenix->search_id_creator = $result['id_user'];

				// Return final URL
				$final_url = $this->panda->array_to_url($var_array, $result['url'], $urlencode);

				//echo $final_url; -> Deprecated -> This is directly inside the understand function module

				// Exception for %2F -> / -> Server will find a big error if we encode it, so let's decode it
				$final_url = str_replace('%2F', '/', $final_url);

				if (!$final_url) $this->index();

				// We stop the benchmarking if it's an intern_url (this way of detection is shit but i didn't make a system yet)
				if ($opt_raw_benchmark) if (is_intern_url($final_url)) $this->benchIt(FALSE);

				/*
				 *
				 * THROW INTERN URL EXCEPTION :
				 * If there's an intern_url detected, we call mistertools and exit(); the application
				 * Otherwise the code will continue
				 *
				 */
				$this->throw_intern_url_exception($final_url, $research_details);

				// http://choualbox.com/box/nsfw/?status=off (bug)

				if ($opt_raw_benchmark) $this->benchIt(FALSE);

				// We set sessions for our Research API (connected with JS)
				$this->connect_research_api($search_text, $final_url, 'normal_process');

					/*
					 * CLEVER RESULT SYSTEM TRANSPARENT RESEARCH CASE
					 * If we do a research with directly within our URL address
					 * We need to show a page to load our JS scripts
					 *
					 * NOTE : WHY DO WE CHECK 'result_attachment' RESEARCH API ATTRIBUTE ?
					 * This data will be set to FALSE if the MIME type isn't a "to download" type
					 * It means the clever returns shouldn't work if the user will download the 'page'
					 * Which won't be a page but a file.
					 *
					 */
					if (($this->pikachu->get_cookie('prefs_clever_returns_enabled')) && (!$this->pikachu->show('result_attachment', 'research'))) {

						$data['search_text'] = $search_text;
						$data['url_result'] = $final_url;

						$this->load->view('prefs/clever_returns_push', $data);

					} else {

						// We redirect the user at the end
						direct($final_url);
						exit();

					}

				} else {

				if ($opt_raw_benchmark) $this->benchIt(FALSE);

				Devlog::add('No standard result found for your entry');

				$this->no_result($result, $research_details);

			}

		} else {

			$this->connect_research_api(NULL, NULL, 'form_error');

			direct(base_url());
			exit();

		}
	}

	/**
	 * No result function call : when there\'s no result from our search
	 *
	 * @access private
	 * @param mixed $result the result or our research
	 * @param array $research_details the search_text, string (cleaned research), by_specific_user, ... details
	 * @return	void
	 */
	private function no_result($result, array $research_details) {

		// We extract everything
		extract($research_details);

		/**
		*
		* We load all the PREFS system because there's no result in this research
		*
		*/
		$prefs_default_result_enabled = get_boolean_prefs('prefs_default_result_enabled');
		$prefs_smart_domains_enabled = get_boolean_prefs('prefs_smart_domains_enabled');

		/**
		*
		* SMART DOMAINS SYSTEM :
		* If there's a one word research, when the smart domains system is enabled
		* we'll search trough our database to find a valid domain to redirect on
		*
		*/
		if (!strpos($search_text, ' ')) {

			// If it's enabled in our preferences
			if ($prefs_smart_domains_enabled) {

				if ($result = $this->general_model->find_auto_url($search_text, $by_specific_user)) {

					// We will split this url into an array
					$arr_recomposed_url = parse_url($result);

					// We will recompose it logically with protocol + domain
					$final_url = $arr_recomposed_url['scheme'] . '://' . $arr_recomposed_url['host'];

					$this->connect_research_api($search_text, $final_url, 'smart_domain');

					// We finally redirect the user
					direct($final_url);
					exit();

				}

			}

		}

		// If we're on a specific search engine (from a space) we could go through a space_redirection
		if ($by_specific_user) {

			if ($space_redirection_raw = $this->log_model->get_user_detail('space', $by_specific_user, 'space_redirection')) {

				// Maybe it's too heavy : if it goes too slowly think about just allowing {SEARCH} within redirections

				$space_redirection = $this->panda->understand_functions($space_redirection_raw);

				$this->connect_research_api($search_text, $space_redirection, 'space_redirection');

				// If the space redirection is an intern_url
				$this->throw_intern_url_exception($space_redirection, $research_details);

				direct($space_redirection);
				exit();

			}

		}

		/**
		*
		* DEFAULT RESULT SYSTEM
		* There's no result, we're looking for a solution, it's going through our favorite search engine
		* Usually Google
		*
		*/
		if ($prefs_default_result_enabled) {

			// Changed 13/12/12 -> Way faster. But not really cool
			//$final_url = LINKBREAKERS_NO_RESULT_REDIRECTION.rawurlencode($search_text);

			// Changed 11/11/13 -> After a year of development, i understood i should buy good servers instead of sacrifying my fucking code for performance
			$prefs_default_result_url_raw = $this->pikachu->get_cookie('prefs_default_result_url');

			// If the user isn't logged-in or there's a problem with the cookie
			if (empty($prefs_default_result_url_raw)) $prefs_default_result_url_raw = LINKBREAKERS_NO_RESULT_REDIRECTION;

			$prefs_default_result_url = $this->panda->understand_functions($prefs_default_result_url_raw);

			$this->connect_research_api($search_text, $prefs_default_result_url, 'default_result');

			// If there's an intern_url within the default result entry
			$this->throw_intern_url_exception($prefs_default_result_url, $research_details);

			$final_url = $prefs_default_result_url;

			// Final URL
			direct($final_url);
			exit();

		} else {

			$this->connect_research_api($search_text, NULL, 'tag_result');

			$this->form_validation->set_post('string', $search_text);
			$this->template->launch('add_tag');

		}

		return FALSE;

	}

}